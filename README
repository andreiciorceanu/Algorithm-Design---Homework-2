324CA Ciorceanu Andrei-Razvan
Tema 2 PA

Problema 1:
	In aceasta problema vom tine 2 matrici, una cu caracterele citite(adica tipurile de poduri),pe care se va deplasa gigel si alta matrice de drum in care calculam pentru fiecare celula,
drumul minim,astfel incat gigel sa se poata deplasa spre mal pe un drum minim. Vom tine niste vectori de deplasari pe care ii vom aduna la pozitia noastra curenta(initializati cu -1,0,1 in functie de
deplasarea pe care o va face gigel si in ce directie),citim cele 2 matrici si datele din fisier,matricea de drum minim va fi initializata cu 0 iar pentru pozitiile in care se afla '.' in matricea de
caractere vom pune -1,deoarece gigel nu poate ajunge in aceste pozitii. Vom initializa o coada pentru aplicarea algoritmului lui Lee in care adaugam prima data pozitia initiala,de start a lui gigel,
si dupa ce luam fiecare caz de deplasare (toate tipurile de pod care se pot afla in acea celula),vom lua vectorii de parcurgere pentru acel tip de pod orizontali/verticali si verificam daca se poate ajunge
in celula urmatoare,si daca gigel nu a mai trecut pe acolo inainte deoarece ne dorim gasirea drumului minim de iesire a lui gigel pe mal. Verificam toate tipurile de cazuri pentru caracterul gasit la pozitia curent a lui gigel,daca este un pod orizontal/vertical sau dublu cel dublu fiind o combinatie a celor 2 cazuri, iar daca celula urmatoare respecta toate condiitle impuse(se poate ajunge in ea,nu
este marcata cu '.',iar drumul pana acolo este unul minim,nu a mai trecut inainte prin acea celula), aceasta noua celula este adaugata in coada,iar acest procedeu se repeta pana cand coada devine vida,insemnand ca gigel a ajuns la marginea matricei de caractere sau a ramas blocat in aceasta matrice.
	Am initializat un min cu INT_MAX pe care il vom compara cu drumul parcurs pana la marginea matricei,unde vom verifica toate cazurile in care gigel a ajuns pe ultima/linie coloana sau pe prima
linie/coloana sau in unul din colturile matricei. Daca gigel se afla in unul din aceste cazuri, luam toate celulele de pe ultima linie/coloana,prima linie/coloana verificam daca gigel poate ajunge acolo
si daca exista un tip de pod orizontal/vertical in functie de ce pozitie a ajuns pentru a ajunge pe mal.Pentru toate aceste celule vom lua celula in care se ajunge pe un drum minim si prin care deasemenea
gigel poate iesi din matrice,verificand separat cazurile pentru care gigel ajunge in colturile matricei de caractere. Comparam din nou min cu valoarea cu care a fost initializat si daca aceasta este diferita inseamna ca gigel a putut ajunge pe mal si afisam min,daca min == INT_MAX afisam -1 deoarece inseamna ca gigel nu a putut ajunge pe mal. Complexitatea problemei este data de complexitatea alg lui Lee prin care aflam drumul minim parcurs de gigel si pentru matricea noastra de caractere de dimensiuni M si N,aceasta complexitate este de O(M*N).

Problema 2:
	In aceasta problema vom tine un pointer 2D pentru numele persoanelor deoarece numele este reprezentat ca un sir de caractere,un vector pentru numarul de emailuri ale fiecarei persoane si un vector 3D pentru a tine emailurile fiecarei persoane deoarece emailurile reprezinta un sir de siruri de caractere. Citim datele din fisier,numarul de persoane,pentru fiecare persoana citim un nume,un nr de emailuri si emailurile acestei persoane.Apoi vom parcurge toate persoanele si le vom compara lista de emailuri,iar in cazul in care gasim 2 adrese de email identice vom apela functia combinePersons care ne va uni persoanele intr-una singura.(daca au 2 adrese identice folosite de nume diferite inseamna ca este vorba despre aceeasi persoana). In functia combinePersons vom aloca memorie pentru noua persoana creata din imbinarea celor 2 si a adreselor lor,vom pastra numele cel mai mic din punct de vedere lexico grafic,dupa care vom adauga intr o lista de emailuri doar emailurile primei persoane si apoi celelate emailuri de la 2 a persoana care sunt diferite de emailurile primei persoane. Dupa care eliberam memoria pentru persoanele deja alocate si vom retine in alte variabile numele persoanei noi,nr de emailuri obtinut din suma nr de emailuri de la cele 2 persoane - nr de emailuri comune,si lista noua de emailuri care va contine emailurile primei persoane si emailurile celei de a doua a persoana care nu se regasesc printre primele. Dupa ce am facut toate aceste verifica vom face niste sortari listelor noastre initiale pentru a le afisa asa cum este precizat in enunt,numele fiind sortate in functie de nr de emailuri prima data apoi lexicografic,iar apoi vom sorta si emailurile lexicografic dupa care le vom afisa in fisier si vom inchide fisierele.
Complexitatea pentru functia combinePersons a parcurgerii emailurilor uneii persoane este O(K),iiar pentru eliminarea unei persoane din vectorul de persoane cat si a nr de emailuri din vectorul de numere si a emailurilor din vectorul de emailuri se face in O(N).
Pentru compararea persoanelor si a emailurilor fiecaruia,dupa apelarea functiei combinePersons avem o complexitate de O(N*N*K*K) * O(N),deci de O(N^3*K^2),pentru  sortarea numelor de persoane in functei de nr de emailuri si lexicografic avem o complexitate de O(N^2),iar pentru sortarea emailurilor lexicografic avem o complexitate de O(N*K^2).

Prooblema 3:
	In aceasta problema, deschidem fisierele apoi citim datele necesare problemei,cele 3 numere k semnificand dimensiune maxima a pieselor, n nr maxim de piese selectate(cate piese de baza avemm) si t nr maxim de piese care pot fi folosite. Initializam prima piesa de baza care trebuie sa inceapa mereu cu 1,dupa care apelam functia lego_back in care vom construii sumele. In functia lego_back daca nu am ajuns deja la n piese de baza,mai putem adauga astfel de piese de baza,dupa care apelam din nou aceasta functie,recursiv pentru a obtine cele n piese de baza. In momentul in care am obtinut cele n piese de baza,putem sa incepem sa calculam sumele distince obtinute cu aceste piese,pentru care apelam functia lego_-back_sum. Avem un vector global in care tinem aceste sume distince, iair pentru fiecare suma noua parcurgem acest vector pentru a vedea daca deja exista,daca nu exista o adaugam la vector si crestem dimensiunea lui. Verificam daca am folosit t piese,numarul maxim precizat in enunt,iar daca nu se intampla acest lucru apelam din nou recursiv aceasta functie cu o noua piese din vectorul celor de baza,pe care o adaugam la suma curenta.
	In functia sume_distince_consecutive,parcurgem vectorul de sume cu 2 for uri pentru a le ordona in ordine crescatoare,apoi parcurgem din nou vectorul pentru a vedea cate sume consecutive avem,pe care le numaram in variabila count si le comparam cu un max pe care il returnam.La final afisam in fisier nr reprezentand cel mai mare nnr de dimensiuni consecutive care poate fi obtinut,apoi afisam diemnsiunile pieselor de baza cu care putem forma aceste dimensiuni.Comlexitatea algoritmului este O(n^t).
